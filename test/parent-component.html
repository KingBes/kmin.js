<template>
    <div class="parent-container">
        <h2>父组件</h2>
        <p>子组件当前值: {{ childCount.value }}</p>
        <button @click="resetChild">调用子组件重置</button>
        <button @click="addFive">调用子组件+5</button>
        <!-- 引入子组件 -->
        <child-component id="myChild"></child-component>
    </div>
</template>

<style>
    .parent-container {
        border: 2px solid #333;
        padding: 15px;
    }

    button {
        margin-right: 10px;
        padding: 4px 8px;
    }
</style>

<script type="module">
    import { KMin } from '../src/kmin.js';

    customElements.define('parent-component', class extends KMin {
        constructor() {
            super();
            // 父组件状态：存储子组件传递的值
            this.childCount = this.state({
                value: 0
            });
            this.event = new Event(this); // 事件派发
        }

        // 父组件挂载时监听子组件事件
        connectedCallback() {
            super.connectedCallback(); // 调用父类方法确保更新

            // 注册子组件
            this.event.register('counter', "#myChild")
            // 监听子组件事件
            this.event.on('counter', 'count-changed', (data) => {
                this.handleChildChange(data.detail);
            });
        }

        // 处理子组件传递的事件
        handleChildChange(data) {
            console.log('父组件收到子组件消息：', data);
            this.childCount.value = data.value; // 更新父组件状态
            // this.updateComponent(); // 手动触发更新（因为childCount不是响应式代理，需手动更新）
        }

        // 调用子组件方法
        resetChild() {
            this.event.call('counter', 'resetValue', 0);
        }

        // 调用子组件方法
        addFive() {
            this.event.call('counter', 'resetValue', this.childCount.value + 5);
        }

        // 清理资源
        disconnectedCallback() {
            this.event.destroy();
        }
    });
</script>